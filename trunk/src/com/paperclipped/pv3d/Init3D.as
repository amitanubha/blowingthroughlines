package com.paperclipped.pv3d{	import flash.display.Sprite;	import flash.display.StageQuality;	import flash.events.Event;	import flash.events.TimerEvent;	import flash.text.TextField;	import flash.utils.Timer;	import flash.utils.getTimer;		import org.papervision3d.cameras.Camera3D;	import org.papervision3d.core.proto.CameraObject3D;	import org.papervision3d.render.BasicRenderEngine;	import org.papervision3d.scenes.Scene3D;	import org.papervision3d.view.Viewport3D;		public class Init3D extends Sprite	{		// Variables		private var _sizeW				:uint;		private var _sizeH				:uint;		private var _baseFPS			:uint;		private var _currentFPS			:uint;		private var _upperThreshold		:uint;		private var _lowerThreshold		:uint;		private var _autoQuality		:Boolean;		private var _quality			:uint;		private var _maxQuality			:uint;		private var _averageFPS			:uint;		private var _fpsArray			:Array;		private var _renderTime			:Number;		private var _qualityTimer		:Timer;		private var _viewport			:Viewport3D;        private var _scene				:Scene3D;        private var _camera				:CameraObject3D;        private var _renderer			:BasicRenderEngine;        private var _showFPS			:Boolean;		private var _fpsTxt				:TextField;//		private var _manualQuality		:String;				// Getters		public function get viewport()	:Viewport3D 			{ return _viewport; 	}        public function get scene()		:Scene3D 				{ return _scene; 		}        public function get camera()	:CameraObject3D 		{ return _camera; 		}        public function get renderer()	:BasicRenderEngine 		{ return _renderer; 	}        public function get fps()		:uint					{ return _currentFPS;	}        public function get quality()	:uint					{ return _quality;		}		public function get autoQuality():Boolean				{ return _autoQuality;	}						// Setters		public function set autoQuality(val	:Boolean):void			{	_autoQuality = val;		}		public function set camera(val		:CameraObject3D):void	{ 	_camera	= val;			}//		public function set showFPS(val		:Boolean):void				{ //																  	_showFPS	= val;//																  	if(_showFPS)//																  	{//																  		_fpsTxt.visible = true;//																  	}else//																  	{//																  		_fpsTxt.visible = false;//																  	}//																}		public function set quality(val:uint):void			{																	//something																	if(val > _maxQuality) val = _maxQuality;																	if(val > 0)																	{																		_autoQuality = false;																		_quality = val;																	}else{																		_autoQuality = true;																	}																}				// Constructor			public function Init3D(sizeW:uint=640, sizeH:uint=480, upperFPS:uint=40, lowerFPS:uint=10):void		{			_upperThreshold = upperFPS;			_lowerThreshold = lowerFPS;			_sizeW 			= sizeW;			_sizeH 			= sizeH;			_autoQuality	= true;			init();		}				private function init():void		{			_maxQuality		= 4;			_viewport 		= new Viewport3D(_sizeW, _sizeH, true, true);//			_viewport		= new BitmapViewport3D(			_viewport.autoScaleToStage = false;//			_viewport.updateAfterRender(			_scene 			= new Scene3D();        	_camera 		= new Camera3D();        	_camera.zoom	= 1000;        	_camera.focus	= 1;        	_renderer 		= new BasicRenderEngine();        	_fpsArray		= new Array();			_averageFPS 	= 30;			_quality		= _maxQuality;			_qualityTimer 	= new Timer(1000, 0);						addChild(_viewport);			this.addEventListener(Event.ADDED_TO_STAGE, setupStage);		}								// Methods		public function pause():void		{ 			this.removeEventListener(Event.ENTER_FRAME, render);		}				public function resume():void		{ 			this.addEventListener(Event.ENTER_FRAME, render);		}				public function kill():void		{			_viewport.destroy();			_qualityTimer.stop();			this.removeEventListener(Event.ENTER_FRAME, render);			_qualityTimer.removeEventListener(TimerEvent.TIMER, setQuality);			removeChild(_viewport);			_viewport		= null;						//something needs to be more removed here		}				public function render(e:Event=null):void		{//			trace("r", this.name)			_renderer.renderScene(_scene, _camera, _viewport);						getFPS();		}					private function setQuality(evt:TimerEvent):void		{			var currQuality:uint = _quality;						if(_averageFPS > _upperThreshold && _quality < 4) _quality ++;			if(_averageFPS < _lowerThreshold && _quality > 2) _quality --;						if(_quality != currQuality && _autoQuality)			{				switch(_quality)				{					case 5:					stage.quality = StageQuality.BEST;					break;										case 4:					stage.quality = StageQuality.HIGH;					break;										case 3:					stage.quality = StageQuality.HIGH;					trace("setting MEDIUM HIGH");					break;										case 2:					stage.quality = StageQuality.MEDIUM;					break;										case 1:					stage.quality = StageQuality.LOW;					break;				}				trace("changing quality to:", stage.quality);			}		}				private function setupStage(evt:Event):void		{			// this is a minor (mostly harmless) hack to force the rendering to look better from the start. (flash bug not pv3d bug...)			this.parent.stage.quality 	= StageQuality.BEST;			_baseFPS 					= this.parent.stage.frameRate;			_renderTime 				= getTimer();			// render the scene normally.			this.addEventListener(Event.ENTER_FRAME, render);						// only want to check on render time once a second so that we don't over do it...						_qualityTimer.addEventListener(TimerEvent.TIMER, setQuality);			this.stage.addEventListener(Event.RESIZE, handleResize);			this.stage.dispatchEvent(new Event(Event.RESIZE));			_qualityTimer.start();			customizeContextMenu();		}				private function getFPS():void		{			_currentFPS 	= Math.ceil(1000/(getTimer() - _renderTime));			_renderTime 	= getTimer();						if(_fpsArray.length >= 30) _fpsArray.splice(0,1);			_fpsArray.push(_currentFPS);						var average:uint = 0;			for(var i:uint=_fpsArray.length-1; i >0; i--)			{				average += _fpsArray[i];			}						_averageFPS = average / _fpsArray.length;		}				private function handleResize(evt:Event):void		{			//var evenOffset:int = _viewport.width%2;			_viewport.viewportWidth = this.parent.stage.stageWidth - (this.parent.stage.stageWidth%2) + 1;			_viewport.viewportHeight = this.parent.stage.stageHeight - (this.parent.stage.stageHeight%2);									trace("Now the viewport is ", _viewport.width, "wide, and the stage is", this.parent.stage.stageWidth, "wide.");			trace("Now the viewport is ", _viewport.height,"high, and the stage is", this.parent.stage.stageHeight,"high.");		}				private function customizeContextMenu():void		{			//trace(stage.contextMenu);		} 	}}