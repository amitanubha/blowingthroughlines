/**	Scroller**	Description:*	Simple scrollbar with easing and throwing that can be set to a vertical scroll or horizontal scroll. By default, the*	scrollbar is set to horizontal and easing is on.**	Usage:*	var myScroller:Scroller = new Scroller(displayObjectToScroll, "horizontal" or "vertical", true);*	myScroller.dragLength = 635;*	myScroller.visibleLength = 735;*	myScroller.drawIt();*	*	Setters*	myScroller.trackBgColor		= 0xFFFFFF;*	myScroller.trackLineColor	= 0x000000;*	myScroller.handleBgColor	= 0x333333;**	Now with ScrollWheel Support!*	For scrollwheel on a Mac, please include the pixelbreaker js file, and use swfObject 1.5 or 2.0 for embedding the flash*/package com.paperclipped.ui{	import flash.display.*;	import flash.events.*;	import flash.text.*;	import flash.geom.*;	import flash.net.*;	import flash.utils.*;		import com.pixelbreaker.ui.osx.MacMouseWheel;	import caurina.transitions.Tweener;		public class Scroller extends Sprite 	{		public static const ON_SCROLL:String = "on_scroll";		public static const ON_SCROLL_START:String = "on_scroll_start";		public static const ON_SCROLL_STOP:String = "on_scroll_stop";				private var isScrollBarNeeded:Boolean;				private var scroll_mc:DisplayObject;		public var sDepth:uint = 10;		public var dragLength:uint;		public var visibleLength:uint;		public var origin:uint;		private var scrollableLength:uint;		private var pageLength:uint;		private var grip:ScrollGripper;				private var handle:MovieClip;		private var track_bg:Sprite;		private var handleMask:Sprite;		private var track:Rectangle;				private var sDir:String;				public var scrollPercent:Number;				private var dragTimer:Timer;				private var easingOn:Boolean;		//Easing		private var trackVel:Number;		public var ease:Number = .8;				//Throwing		private var thisLoc:Number = 0;		private var lastLoc:Number = 0;				private var handleLength:Number;				//Colors		private var trackColor:uint;		private var trackOutlineColor:uint;		private var handleColor:uint;		private var scrollWheel:Boolean;				public function Scroller(mc:DisplayObject, dir:String = "horizontal", easing:Boolean = true):void 		{			//this.scroll_mc == factHolder sprite			this.scroll_mc = mc;						this.dragTimer = new Timer(30, 0);			this.sDir = dir;			this.easingOn = easing;						// Set default colors			this.trackColor			= 0xD5D5D5;			this.trackOutlineColor	= 0xAEAEAE;			this.handleColor		= 0xD64B06;			this.scrollWheel		= true;											}				// Public Setters		public function set trackBgColor(value:uint):void	{		   trackColor = value;}		public function set trackLineColor(value:uint):void {	trackOutlineColor = value;}		public function set handleBgColor(value:uint):void	{		  handleColor = value;}		public function set scrollWheelEnabled(value:Boolean):void	{ scrollWheel = value;}						public function drawIt():void		{															//trace('draw it! ', this.scroll_mc.width);			this.stopObservingDrag();			if(this.handle)			{				this.removeChild(this.handle);			}			if(this.track_bg)			{				this.removeChild(this.track_bg);			}						if(this.sDir == "horizontal")			{				if(scroll_mc.width <= this.visibleLength)				{					isScrollBarNeeded	= false;				}				else				{					isScrollBarNeeded	= true;				}															//this.height = this.sDepth;				this.scrollableLength = (this.scroll_mc.width + 10 ) - this.visibleLength;								handleLength = ((this.visibleLength/this.scroll_mc.width)*this.dragLength);				//trace("handleLength: ", handleLength);				pageLength = handleLength;				if(handleLength == 0)				{					handleLength = this.dragLength;				}				else if(handleLength < 20)				{					handleLength = 20;				}				//trace('handleLength:', handleLength, 'dragLength:', this.dragLength, 'vis width:', this.visibleLength, 'scrollableLength', this.scrollableLength, 'scroll_mc width', this.scroll_mc.width);								this.track = new Rectangle(0,0,(this.dragLength-handleLength),0);												//draq track bg				this.track_bg  = new Sprite();				this.track_bg.graphics.lineStyle(1, this.trackOutlineColor, .6, true, "none", "none", "miter");				this.track_bg.graphics.beginFill( this.trackColor, 1);				//this.track_bg.graphics.beginFill(0x444444);				//this.track_bg.graphics.drawRoundRect(0,0,this.dragLength,this.sDepth, 10);				this.track_bg.graphics.drawRect(0,0,this.dragLength,this.sDepth);				this.track_bg.buttonMode = true;				this.addChild(this.track_bg);				//trace(this.dragLength);								this.handleMask = new Sprite();				this.handleMask.graphics.beginFill(0x444444, 0);				this.handleMask.graphics.drawRect(0,0,this.dragLength,this.sDepth);				this.addChild(this.handleMask);								//draw bar // the handle that is dragged				this.handle = new MovieClip();				this.handle.graphics.beginFill(this.handleColor);				this.handle.graphics.drawRect(0,0,handleLength,this.sDepth);				this.handle.mask = this.handleMask;				this.handle.alpha = 0;				this.handle.buttonMode = true;				Tweener.addTween(this.handle, {alpha:1, time:0.5, transition:"linear"});				this.addChild(this.handle);				this.moveBar(this.scroll_mc.x);								this.grip	= new ScrollGripper();				this.grip.rotation	= 90;				this.grip.y	= 4;				this.grip.x	= Math.ceil((handle.width/2) - (this.grip.width/2));				this.handle.addChild(this.grip);															}			else if (this.sDir == "vertical")			{								if(scroll_mc.height <= this.visibleLength)				{					isScrollBarNeeded	= false;				}				else				{					isScrollBarNeeded	= true;				}								this.scrollableLength = (this.scroll_mc.height + 10 ) - this.visibleLength;								handleLength = ((this.visibleLength/this.scroll_mc.height)*this.dragLength);				pageLength = handleLength;				if(handleLength == 0)				{					handleLength = this.dragLength;				}				else if(handleLength < 20)				{					handleLength = 20;				}								this.track = new Rectangle(0,0,0,(this.dragLength-handleLength));																//draq track bg				this.track_bg  = new Sprite();				this.track_bg.graphics.lineStyle(1, this.trackOutlineColor, .6, true, "none", "none", "miter");				this.track_bg.graphics.beginFill(this.trackColor, 1);				this.track_bg.graphics.drawRect(0,0,this.sDepth,this.dragLength);				this.addChild(this.track_bg);								this.handleMask = new Sprite();				this.handleMask.graphics.beginFill(0x444444, 0);				this.handleMask.graphics.drawRect(0,0,this.sDepth,this.dragLength);				this.addChild(this.handleMask);								//draw bar // the handle that is dragged				this.handle = new MovieClip();				this.handle.graphics.beginFill(this.handleColor);				this.handle.graphics.drawRect(0,0,this.sDepth,handleLength);				this.handle.mask = this.handleMask;				this.handle.alpha = 0;				this.handle.buttonMode = true;				Tweener.addTween(this.handle, {alpha:1, time:0.5, transition:"linear"});				this.addChild(this.handle);				this.moveBar(this.scroll_mc.y);								this.grip	= new ScrollGripper();				this.grip.x	= 4;				this.grip.y	= Math.ceil((handle.height/2) - (this.grip.height/2));				this.handle.addChild(this.grip);							}						if(isScrollBarNeeded)			{				MacMouseWheel.setup( this.stage );								this.handle.addEventListener(MouseEvent.MOUSE_DOWN, this.mouseDown);				this.handle.addEventListener(MouseEvent.MOUSE_UP, this.mouseUp);				this.track_bg.addEventListener(MouseEvent.MOUSE_DOWN, this.movePage);				this.stage.addEventListener( MouseEvent.MOUSE_WHEEL, this.handleMouseWheel );			}			else			{				this.handle.visible		= false;				//this.track_bg.visible	= false;			}		}				private function observeDrag(e:Event):void {			//trace('drag',this.scroll_mc.width);			this.dragTimer.addEventListener(TimerEvent.TIMER, this.onListMove); // add this listener when the timer is made			//this.scroll_mc.addEventListener(ProjectList.END_DRAG, this.onEndDrag);			this.dragTimer.reset();			this.dragTimer.start();		}				private function stopObservingDrag():void {			// not removing the listener here, and stopping the timer when the distance matches up 			// would make more sense for a "tweened" effect			this.dragTimer.stop();			this.dragTimer.removeEventListener(TimerEvent.TIMER, this.onListMove);			//this.scroll_mc.removeEventListener(ProjectList.END_DRAG, this.stopObservingDrag);		}				private function onEndDrag(e:Event):void {			this.stopObservingDrag();		}				private function onListMove(e:Event):void {			// move to the difference of now and where the handle says it should be...			if(this.sDir == "horizontal")			{				this.moveBar(this.scroll_mc.x);			}			else if (this.sDir == "vertical")			{				//function doesn't seem to do anything - Derek			}		}				private function moveBar(xPos):void {			if(this.sDir == "horizontal")			{				this.handle.x = -1*(xPos - this.origin) / this.scrollableLength * this.track.width;			}			else if(this.sDir == "vertical")			{				//function doesn't seem to do anything - Derek			}		}				private function mouseDown(e:MouseEvent):void		{			if(trackVel != 0)			{				trackVel = 0;				stage.removeEventListener(Event.ENTER_FRAME, easePage);			}						stage.addEventListener(MouseEvent.MOUSE_MOVE, throwListener);			//trace('clicking and dragging: '+e.currentTarget);			stage.addEventListener(MouseEvent.MOUSE_UP, this.mouseUp);			stage.addEventListener(Event.MOUSE_LEAVE, this.mouseUp);						this.handle.startDrag(false, this.track);			this.dispatchEvent(new MouseEvent(ON_SCROLL_START)); //TODO disable bubbling			this.handle.addEventListener( Event.ENTER_FRAME, this.drag );			//this.track_bg.removeEventListener(MouseEvent.MOUSE_DOWN, this.movePage); // not a bad idea, but not the culprit		}				private function throwListener(evt:Event):void		{			if(this.sDir == "horizontal")			{				lastLoc = thisLoc;				thisLoc = this.handle.x;				trackVel = (thisLoc - lastLoc)/2;			}			else if(this.sDir == "vertical")			{				lastLoc = thisLoc;				thisLoc = this.handle.y;				trackVel = (thisLoc - lastLoc)/2;			}		}				private function mouseUp(e:Event):void		{			this.handle.removeEventListener( Event.ENTER_FRAME, this.drag );			this.handle.stopDrag();			//this.handle.removeEventListener(MouseEvent.MOUSE_UP, this.mouseUp);			stage.removeEventListener(MouseEvent.MOUSE_UP, this.mouseUp);			stage.removeEventListener(Event.MOUSE_LEAVE, this.mouseUp);			stage.removeEventListener(MouseEvent.MOUSE_MOVE, throwListener);			if(easingOn)			{				stage.addEventListener(Event.ENTER_FRAME, easePage);			}						this.drag(new Event(Event.ENTER_FRAME));						//this.scroll_mc.dispatchEvent(new Event(ProjectList.LIST_MOVED));			this.dispatchEvent(new MouseEvent(ON_SCROLL_STOP));			//this.track_bg.addEventListener(MouseEvent.MOUSE_DOWN, this.movePage); though this was making it move when held down, but it's something else		}				private function drag(e:Event):void		{			if(this.sDir == "horizontal")			{				if(this.track.width != 0) {					this.scrollPercent = this.handle.x/this.track.width;					this.scroll_mc.x = -((this.handle.x/this.track.width) * this.scrollableLength) + this.origin;				}				//this.scroll_mc.x = -((this.scrollPercent * this.scroll_mc.width));			}			else if (this.sDir == "vertical")			{				if(this.track.height != 0) {					this.scrollPercent = this.handle.y/this.track.height;					this.scroll_mc.y = -((this.handle.y/this.track.height) * this.scrollableLength) + this.origin;				}			}			this.dispatchEvent(new MouseEvent(ON_SCROLL));		}		private function movePage(e:Event):void		{			if(easingOn)			{				//var moveTo:Number;				if(this.sDir == "horizontal")				{					if(this.mouseX < this.handle.x){						//moveTo = this.handle.x-pageLength;						//if(moveTo < this.track.x) moveTo = this.track.x;						trackVel += -10;					}else{						//moveTo = this.handle.x+pageLength;						//if(moveTo > this.track.x+this.track.width) moveTo = this.track.x+this.track.width;						trackVel += 10;					}					//moveTo = Math.round(moveTo);					this.handle.addEventListener( Event.ENTER_FRAME, this.drag );					this.dispatchEvent(new MouseEvent(ON_SCROLL_START));					this.handle.dispatchEvent( new Event(MouseEvent.MOUSE_UP));					this.dispatchEvent(new MouseEvent(ON_SCROLL_STOP));				}				else if (this.sDir == "vertical")				{					if(this.mouseY < this.handle.y){						//moveTo = this.handle.y-pageLength;						//if(moveTo < this.track.y) moveTo = this.track.y;						trackVel += -10;					}else{						//moveTo = this.handle.y+pageLength;						//if(moveTo > this.track.y+this.track.height) moveTo = this.track.y+this.track.height;						trackVel += 10;					}					//moveTo = Math.round(moveTo);					this.handle.addEventListener( Event.ENTER_FRAME, this.drag );					this.dispatchEvent(new MouseEvent(ON_SCROLL_START));					this.handle.dispatchEvent( new Event(MouseEvent.MOUSE_UP));					this.dispatchEvent(new MouseEvent(ON_SCROLL_STOP));				}				stage.addEventListener(Event.ENTER_FRAME, easePage);			}			else			{				var moveTo:Number;				if(this.sDir == "horizontal")				{					if(this.mouseX < this.handle.x){						moveTo = this.handle.x-pageLength;						if(moveTo < this.track.x) moveTo = this.track.x;						trackVel += -10;					}else{						moveTo = this.handle.x+pageLength;						if(moveTo > this.track.x+this.track.width) moveTo = this.track.x+this.track.width;						trackVel += 10;					}					moveTo = Math.round(moveTo);					this.handle.x = moveTo;					this.handle.addEventListener( Event.ENTER_FRAME, this.drag );					this.dispatchEvent(new MouseEvent(ON_SCROLL_START));					this.handle.dispatchEvent( new Event(MouseEvent.MOUSE_UP));					this.dispatchEvent(new MouseEvent(ON_SCROLL_STOP));				} 				else if (this.sDir == "vertical")				{					if(this.mouseY < this.handle.y){						moveTo = this.handle.y-pageLength;						if(moveTo < this.track.y) moveTo = this.track.y;						trackVel += -10;					}else{						moveTo = this.handle.y+pageLength;						if(moveTo > this.track.y+this.track.height) moveTo = this.track.y+this.track.height;						trackVel += 10;					}					moveTo = Math.round(moveTo);					this.handle.y = moveTo;					this.handle.addEventListener( Event.ENTER_FRAME, this.drag );					this.dispatchEvent(new MouseEvent(ON_SCROLL_START));					this.handle.dispatchEvent( new Event(MouseEvent.MOUSE_UP));					this.dispatchEvent(new MouseEvent(ON_SCROLL_STOP));				}			}		}		private function easePage(evt:Event):void		{			if(this.sDir == "horizontal")			{				this.handle.x += trackVel;				if(this.handle.x <= 0)				{					this.handle.x = 0;					trackVel = 0;					stage.removeEventListener(Event.ENTER_FRAME, easePage);				}				if(this.handle.x >= this.track.width)				{					this.handle.x = this.track.width;					trackVel = 0;					stage.removeEventListener(Event.ENTER_FRAME, easePage);				}			}			else if(this.sDir == "vertical")			{				this.handle.y += trackVel;				if(this.handle.y <= 0)				{					this.handle.y = 0;					trackVel = 0;					stage.removeEventListener(Event.ENTER_FRAME, easePage);				}				if(this.handle.y >= this.track.height)				{					this.handle.y = this.track.height;					trackVel = 0;					stage.removeEventListener(Event.ENTER_FRAME, easePage);				}			}			trackVel *= ease;			this.handle.dispatchEvent( new Event(MouseEvent.MOUSE_UP));			this.dispatchEvent(new MouseEvent(ON_SCROLL_STOP));			if(trackVel <= .2 && trackVel >= -.2)			{				trackVel = 0;				stage.removeEventListener(Event.ENTER_FRAME, easePage);			}		}				private function handleMouseWheel(evt:MouseEvent):void		{			// this is where all the magic happens, unless the JS file isn't found...			this.handle.dispatchEvent(new MouseEvent(MouseEvent.MOUSE_DOWN));			if(this.sDir == "horizontal")			{				this.handle.x -= evt.delta;			}			else			{				this.handle.y -= evt.delta;			}						this.handle.dispatchEvent(new MouseEvent(MouseEvent.MOUSE_UP));		}	}}